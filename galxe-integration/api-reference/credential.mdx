---
title: "Credential API Reference"
description: "Manage user credentials, check eligibility, and handle verification workflows"
---

## Overview

- Check user eligibility for credentials
- Manage credential verification status
- Track credential metrics
- Sync credential data

## Core Queries

### `credential` - Get Credential Details

Find Credential details by Credential ID.

**Arguments**: `id` (required) - Credential's unique ID

**Key Fields**: `id`, `name`, `description`, `credType`, `credSource`, `itemCount`, `syncStatus`, `eligible(address: String!)`

#### Example: Basic Credential Query

```graphql
query GetCredential($credId: ID!) {
  credential(id: $credId) {
    id
    name
    description
    credType
    credSource
    itemCount
    syncStatus
  }
}
```

**Response**:
```json
{
  "data": {
    "credential": {
      "id": "473720589215887360",
      "name": "Visit the Google",
      "description": "Users who have visited the page",
      "credType": "EVM_ADDRESS",
      "credSource": "VISIT_LINK",
      "itemCount": 3,
      "syncStatus": "SYNCED"
    }
  }
}
```

## User Eligibility

### Check User Eligibility

Check if a specific user meets credential requirements.

```graphql
query CheckUserEligibility($credId: ID!, $address: String!) {
  credential(id: $credId) {
    id
    name
    eligible(address: $address)
    syncStatus
  }
}
```

**Response**:
- `eligible: 1` - User has the credential
- `eligible: 0` - User does not have the credential

## Code Examples

<CodeGroup>
```javascript JavaScript
class CredentialManager {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.apiUrl = 'https://graphigo-business.prd.galaxy.eco/query';
  }

  async getCredential(credId) {
    const query = `
      query GetCredential($credId: ID!) {
        credential(id: $credId) {
          id
          name
          description
          credType
          itemCount
          syncStatus
        }
      }
    `;

    const response = await fetch(this.apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'access-token': this.accessToken
      },
      body: JSON.stringify({ query, variables: { credId } })
    });

    const data = await response.json();
    return data.data.credential;
  }

  async checkEligibility(credId, userAddress) {
    const query = `
      query CheckEligibility($credId: ID!, $address: String!) {
        credential(id: $credId) {
          eligible(address: $address)
        }
      }
    `;

    const response = await fetch(this.apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'access-token': this.accessToken
      },
      body: JSON.stringify({ 
        query, 
        variables: { credId, address: userAddress } 
      })
    });

    const data = await response.json();
    return data.data.credential.eligible === 1;
  }
}

// Usage
const manager = new CredentialManager(process.env.GALXE_ACCESS_TOKEN);

const credential = await manager.getCredential('473720589215887360');
console.log(`Credential: ${credential.name}`);

const eligible = await manager.checkEligibility('473720589215887360', '0x1234...');
console.log('User eligible:', eligible);
```

```go Go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
)

type CredentialManager struct {
    accessToken string
    apiURL      string
}

type Credential struct {
    ID          string `json:"id"`
    Name        string `json:"name"`
    Description string `json:"description"`
    CredType    string `json:"credType"`
    ItemCount   int    `json:"itemCount"`
    SyncStatus  string `json:"syncStatus"`
}

type GraphQLRequest struct {
    Query     string                 `json:"query"`
    Variables map[string]interface{} `json:"variables"`
}

type CredentialResponse struct {
    Data struct {
        Credential Credential `json:"credential"`
    } `json:"data"`
}

type EligibilityResponse struct {
    Data struct {
        Credential struct {
            Eligible int `json:"eligible"`
        } `json:"credential"`
    } `json:"data"`
}

func NewCredentialManager(accessToken string) *CredentialManager {
    return &CredentialManager{
        accessToken: accessToken,
        apiURL:      "https://graphigo-business.prd.galaxy.eco/query",
    }
}

func (cm *CredentialManager) GetCredential(credID string) (*Credential, error) {
    query := `
        query GetCredential($credId: ID!) {
            credential(id: $credId) {
                id
                name
                description
                credType
                itemCount
                syncStatus
            }
        }
    `

    variables := map[string]interface{}{
        "credId": credID,
    }

    reqBody := GraphQLRequest{
        Query:     query,
        Variables: variables,
    }

    jsonBody, err := json.Marshal(reqBody)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }

    req, err := http.NewRequest("POST", cm.apiURL, bytes.NewBuffer(jsonBody))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("access-token", cm.accessToken)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }

    var response CredentialResponse
    if err := json.Unmarshal(body, &response); err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    return &response.Data.Credential, nil
}

func (cm *CredentialManager) CheckEligibility(credID, userAddress string) (bool, error) {
    query := `
        query CheckEligibility($credId: ID!, $address: String!) {
            credential(id: $credId) {
                eligible(address: $address)
            }
        }
    `

    variables := map[string]interface{}{
        "credId":  credID,
        "address": userAddress,
    }

    reqBody := GraphQLRequest{
        Query:     query,
        Variables: variables,
    }

    jsonBody, err := json.Marshal(reqBody)
    if err != nil {
        return false, fmt.Errorf("failed to marshal request: %w", err)
    }

    req, err := http.NewRequest("POST", cm.apiURL, bytes.NewBuffer(jsonBody))
    if err != nil {
        return false, fmt.Errorf("failed to create request: %w", err)
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("access-token", cm.accessToken)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return false, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return false, fmt.Errorf("failed to read response: %w", err)
    }

    var response EligibilityResponse
    if err := json.Unmarshal(body, &response); err != nil {
        return false, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    return response.Data.Credential.Eligible == 1, nil
}

// Usage
func main() {
    manager := NewCredentialManager(os.Getenv("GALXE_ACCESS_TOKEN"))

    credential, err := manager.GetCredential("473720589215887360")
    if err != nil {
        fmt.Printf("Error getting credential: %v\n", err)
        return
    }
    fmt.Printf("Credential: %s\n", credential.Name)

    eligible, err := manager.CheckEligibility("473720589215887360", "0x1234...")
    if err != nil {
        fmt.Printf("Error checking eligibility: %v\n", err)
        return
    }
    fmt.Printf("User eligible: %v\n", eligible)
}
```

```python Python
import os
import aiohttp
import asyncio
from typing import Dict, Any, Optional

class CredentialManager:
    def __init__(self, access_token: str):
        self.access_token = access_token
        self.api_url = "https://graphigo-business.prd.galaxy.eco/query"
    
    async def get_credential(self, cred_id: str) -> Optional[Dict[str, Any]]:
        query = """
            query GetCredential($credId: ID!) {
                credential(id: $credId) {
                    id
                    name
                    description
                    credType
                    itemCount
                    syncStatus
                }
            }
        """
        
        variables = {"credId": cred_id}
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                self.api_url,
                headers={
                    "Content-Type": "application/json",
                    "access-token": self.access_token
                },
                json={"query": query, "variables": variables}
            ) as response:
                data = await response.json()
                return data["data"]["credential"]
    
    async def check_eligibility(self, cred_id: str, user_address: str) -> bool:
        query = """
            query CheckEligibility($credId: ID!, $address: String!) {
                credential(id: $credId) {
                    eligible(address: $address)
                }
            }
        """
        
        variables = {"credId": cred_id, "address": user_address}
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                self.api_url,
                headers={
                    "Content-Type": "application/json",
                    "access-token": self.access_token
                },
                json={"query": query, "variables": variables}
            ) as response:
                data = await response.json()
                return data["data"]["credential"]["eligible"] == 1

# Usage
async def main():
    manager = CredentialManager(os.getenv("GALXE_ACCESS_TOKEN"))
    
    credential = await manager.get_credential("473720589215887360")
    print(f"Credential: {credential['name']}")
    
    eligible = await manager.check_eligibility("473720589215887360", "0x1234...")
    print(f"User eligible: {eligible}")

if __name__ == "__main__":
    asyncio.run(main())
```
</CodeGroup>

## Common Use Cases

### Batch Eligibility Check

<CodeGroup>
```javascript JavaScript
async function checkMultipleUsers(credId, addresses) {
  const results = await Promise.all(
    addresses.map(async (address) => {
      try {
        const eligible = await manager.checkEligibility(credId, address);
        return { address, eligible };
      } catch (error) {
        return { address, eligible: false, error: error.message };
      }
    })
  );

  return {
    total: addresses.length,
    eligible: results.filter(r => r.eligible).length,
    results
  };
}
```

```go Go
package main

import (
    "fmt"
    "sync"
)

type EligibilityResult struct {
    Address  string `json:"address"`
    Eligible bool   `json:"eligible"`
    Error    string `json:"error,omitempty"`
}

type BatchResult struct {
    Total    int                 `json:"total"`
    Eligible int                 `json:"eligible"`
    Results  []EligibilityResult `json:"results"`
}

func (cm *CredentialManager) CheckMultipleUsers(credID string, addresses []string) *BatchResult {
    var wg sync.WaitGroup
    results := make([]EligibilityResult, len(addresses))
    
    for i, address := range addresses {
        wg.Add(1)
        go func(index int, addr string) {
            defer wg.Done()
            
            eligible, err := cm.CheckEligibility(credID, addr)
            if err != nil {
                results[index] = EligibilityResult{
                    Address:  addr,
                    Eligible: false,
                    Error:    err.Error(),
                }
            } else {
                results[index] = EligibilityResult{
                    Address:  addr,
                    Eligible: eligible,
                }
            }
        }(i, address)
    }
    
    wg.Wait()
    
    eligibleCount := 0
    for _, result := range results {
        if result.Eligible {
            eligibleCount++
        }
    }
    
    return &BatchResult{
        Total:    len(addresses),
        Eligible: eligibleCount,
        Results:  results,
    }
}
```

```python Python
import asyncio
from typing import List, Dict, Any

class EligibilityResult:
    def __init__(self, address: str, eligible: bool, error: str = None):
        self.address = address
        self.eligible = eligible
        self.error = error
    
    def to_dict(self) -> Dict[str, Any]:
        result = {"address": self.address, "eligible": self.eligible}
        if self.error:
            result["error"] = self.error
        return result

async def check_multiple_users(manager: CredentialManager, cred_id: str, addresses: List[str]) -> Dict[str, Any]:
    async def check_single_user(address: str) -> EligibilityResult:
        try:
            eligible = await manager.check_eligibility(cred_id, address)
            return EligibilityResult(address, eligible)
        except Exception as error:
            return EligibilityResult(address, False, str(error))
    
    results = await asyncio.gather(
        *[check_single_user(address) for address in addresses]
    )
    
    result_dicts = [r.to_dict() for r in results]
    eligible_count = sum(1 for r in results if r.eligible)
    
    return {
        "total": len(addresses),
        "eligible": eligible_count,
        "results": result_dicts
    }
```
</CodeGroup>

### Credential Validation

<CodeGroup>
```javascript JavaScript
async function validateCredential(credId) {
  const credential = await manager.getCredential(credId);
  
  return {
    isValid: credential.syncStatus === 'SYNCED',
    hasHolders: credential.itemCount > 0,
    credential
  };
}
```

```go Go
type ValidationResult struct {
    IsValid    bool        `json:"isValid"`
    HasHolders bool        `json:"hasHolders"`
    Credential *Credential `json:"credential"`
}

func (cm *CredentialManager) ValidateCredential(credID string) (*ValidationResult, error) {
    credential, err := cm.GetCredential(credID)
    if err != nil {
        return nil, fmt.Errorf("failed to get credential: %w", err)
    }
    
    return &ValidationResult{
        IsValid:    credential.SyncStatus == "SYNCED",
        HasHolders: credential.ItemCount > 0,
        Credential: credential,
    }, nil
}
```

```python Python
from typing import Dict, Any

async def validate_credential(manager: CredentialManager, cred_id: str) -> Dict[str, Any]:
    credential = await manager.get_credential(cred_id)
    
    return {
        "isValid": credential["syncStatus"] == "SYNCED",
        "hasHolders": credential["itemCount"] > 0,
        "credential": credential
    }
```
</CodeGroup>

## Error Handling

<CodeGroup>
```javascript JavaScript
async function safeCredentialCheck(credId, userAddress) {
  try {
    const eligible = await manager.checkEligibility(credId, userAddress);
    return { success: true, eligible };
  } catch (error) {
    if (error.message.includes('not found')) {
      return { success: false, error: 'CREDENTIAL_NOT_FOUND' };
    }
    return { success: false, error: 'UNKNOWN', message: error.message };
  }
}
```

```go Go
type SafeCheckResult struct {
    Success  bool   `json:"success"`
    Eligible bool   `json:"eligible,omitempty"`
    Error    string `json:"error,omitempty"`
    Message  string `json:"message,omitempty"`
}

func (cm *CredentialManager) SafeCredentialCheck(credID, userAddress string) *SafeCheckResult {
    eligible, err := cm.CheckEligibility(credID, userAddress)
    if err != nil {
        if fmt.Sprintf("%v", err) == "not found" {
            return &SafeCheckResult{
                Success: false,
                Error:   "CREDENTIAL_NOT_FOUND",
            }
        }
        return &SafeCheckResult{
            Success: false,
            Error:   "UNKNOWN",
            Message: err.Error(),
        }
    }
    
    return &SafeCheckResult{
        Success:  true,
        Eligible: eligible,
    }
}
```

```python Python
from typing import Dict, Any

async def safe_credential_check(manager: CredentialManager, cred_id: str, user_address: str) -> Dict[str, Any]:
    try:
        eligible = await manager.check_eligibility(cred_id, user_address)
        return {"success": True, "eligible": eligible}
    except Exception as error:
        if "not found" in str(error):
            return {"success": False, "error": "CREDENTIAL_NOT_FOUND"}
        return {"success": False, "error": "UNKNOWN", "message": str(error)}
```
</CodeGroup>

## Next Steps

- **[Quest API Reference](/galxe-integration/api-reference/quest)** - Quest management
- **[Space API Reference](/galxe-integration/api-reference/space)** - Leaderboards and points
- **[User Verification Guide](/galxe-integration/guides/user-verification)** - Implementation patterns