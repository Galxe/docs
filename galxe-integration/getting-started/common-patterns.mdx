---
title: "Common Integration Patterns"
description: "Understanding these patterns will help you implement Galxe integration efficiently and correctly"
---

## 1. Quest Status Checking

**Use Case**: Check if a quest is active before allowing participation.

```graphql
query QuestStatus($id: ID!) {
  quest(id: $id) {
    status
    startTime
    endTime
  }
}
```

**Implementation Pattern**:

<CodeGroup>
```javascript JavaScript
const isQuestActive = (quest) => {
  const now = Date.now() / 1000;
  return quest.status === 'Active' && 
         now >= quest.startTime && 
         now <= quest.endTime;
};
```

```go Go
package main

import "time"

type Quest struct {
    Status    string `json:"status"`
    StartTime int64  `json:"startTime"`
    EndTime   int64  `json:"endTime"`
}

func isQuestActive(quest Quest) bool {
    now := time.Now().Unix()
    return quest.Status == "Active" && 
           now >= quest.StartTime && 
           now <= quest.EndTime
}
```

```python Python
import time

def is_quest_active(quest):
    now = int(time.time())
    return (quest['status'] == 'Active' and 
            now >= quest['startTime'] and 
            now <= quest['endTime'])
```
</CodeGroup>

## 2. User Eligibility Verification

**Use Case**: Verify if a user meets quest requirements before showing participation UI.

```graphql
query CheckUserEligibility($questId: ID!, $address: String!) {
  quest(id: $questId) {
    credentialGroups(address: $address) {
      conditions {
        eligible
      }
      rewards {
        eligible
        rewardType
      }
    }
  }
}
```

## 3. Paginated Data Fetching

**Use Case**: Load large datasets efficiently (participants, leaderboards).

```graphql
query GetQuests($spaceId: ID!, $first: Int!, $after: String) {
  quests(input: {
    spaceId: $spaceId
    first: $first
    after: $after
  }) {
    pageInfo {
      hasNextPage
      endCursor
    }
    list {
      id
      name
      participantsCount
      status
    }
  }
}
```

**Implementation Pattern**:

<CodeGroup>
```javascript JavaScript
const fetchAllQuests = async (spaceId) => {
  let allQuests = [];
  let hasNextPage = true;
  let cursor = null;

  while (hasNextPage) {
    const response = await fetchQuests(spaceId, 100, cursor);
    allQuests.push(...response.data.quests.list);
    
    hasNextPage = response.data.quests.pageInfo.hasNextPage;
    cursor = response.data.quests.pageInfo.endCursor;
  }

  return allQuests;
};
```

```go Go
package main

import (
    "encoding/json"
    "fmt"
)

type Quest struct {
    ID               string `json:"id"`
    Name             string `json:"name"`
    ParticipantsCount int   `json:"participantsCount"`
    Status           string `json:"status"`
}

type PageInfo struct {
    HasNextPage bool   `json:"hasNextPage"`
    EndCursor   string `json:"endCursor"`
}

func fetchAllQuests(spaceId string) ([]Quest, error) {
    var allQuests []Quest
    hasNextPage := true
    cursor := ""

    for hasNextPage {
        response, err := fetchQuests(spaceId, 100, cursor)
        if err != nil {
            return nil, fmt.Errorf("failed to fetch quests: %w", err)
        }

        quests := response.Data.Quests.List
        allQuests = append(allQuests, quests...)

        hasNextPage = response.Data.Quests.PageInfo.HasNextPage
        cursor = response.Data.Quests.PageInfo.EndCursor
    }

    return allQuests, nil
}
```

```python Python
async def fetch_all_quests(space_id):
    all_quests = []
    has_next_page = True
    cursor = None

    while has_next_page:
        response = await fetch_quests(space_id, 100, cursor)
        quests = response['data']['quests']['list']
        all_quests.extend(quests)
        
        page_info = response['data']['quests']['pageInfo']
        has_next_page = page_info['hasNextPage']
        cursor = page_info['endCursor']

    return all_quests
```
</CodeGroup>

## 4. Real-time Leaderboard Updates

**Use Case**: Display live leaderboard with user rankings.

```graphql
query LiveLeaderboard($spaceId: Int!, $userAddress: String!) {
  space(id: $spaceId) {
    # Top 10 leaderboard
    loyaltyPointsRanks(first: 10) {
      edges {
        node {
          rank
          points
          address {
            username
            avatar
          }
        }
      }
    }
    
    # Current user position
    addressLoyaltyPoints(address: $userAddress) {
      rank
      points
    }
  }
}
```

## 5. Credential Management

**Use Case**: Manage credential holders for custom verification systems.

### Add Users to Credential
```graphql
mutation AddCredentialHolders($credId: ID!, $addresses: [String!]!) {
  credentialItems(input: {
    credId: $credId
    operation: APPEND
    items: $addresses
  }) {
    eligible(address: $addresses[0])
  }
}
```

### Verify User Credential
```graphql
query VerifyUserCredential($credId: ID!, $address: String!) {
  credential(id: $credId) {
    eligible(address: $address)
  }
}
```

## 6. Error Handling Pattern

<CodeGroup>
```javascript JavaScript
const executeGraphQLQuery = async (query, variables) => {
  try {
    const response = await fetch('https://graphigo-business.prd.galaxy.eco/query', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'access-token': process.env.GALXE_ACCESS_TOKEN
      },
      body: JSON.stringify({ query, variables })
    });

    const data = await response.json();

    if (data.errors) {
      console.error('GraphQL Errors:', data.errors);
      throw new Error(data.errors[0].message);
    }

    return data.data;
  } catch (error) {
    console.error('Network Error:', error);
    throw error;
  }
};
```

```go Go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
)

type GraphQLRequest struct {
    Query     string                 `json:"query"`
    Variables map[string]interface{} `json:"variables,omitempty"`
}

type GraphQLResponse struct {
    Data   interface{}   `json:"data"`
    Errors []GraphQLError `json:"errors,omitempty"`
}

type GraphQLError struct {
    Message    string                 `json:"message"`
    Extensions map[string]interface{} `json:"extensions,omitempty"`
}

func executeGraphQLQuery(query string, variables map[string]interface{}) (interface{}, error) {
    requestBody := GraphQLRequest{
        Query:     query,
        Variables: variables,
    }

    jsonBody, err := json.Marshal(requestBody)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal request: %w", err)
    }

    req, err := http.NewRequest("POST", "https://graphigo-business.prd.galaxy.eco/query", bytes.NewBuffer(jsonBody))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("access-token", os.Getenv("GALXE_ACCESS_TOKEN"))

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("network error: %w", err)
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }

    var response GraphQLResponse
    if err := json.Unmarshal(body, &response); err != nil {
        return nil, fmt.Errorf("failed to unmarshal response: %w", err)
    }

    if len(response.Errors) > 0 {
        return nil, fmt.Errorf("GraphQL error: %s", response.Errors[0].Message)
    }

    return response.Data, nil
}
```

```python Python
import os
import json
import aiohttp
import asyncio

class GraphQLError(Exception):
    def __init__(self, message, extensions=None):
        self.message = message
        self.extensions = extensions
        super().__init__(self.message)

async def execute_graphql_query(query, variables=None):
    headers = {
        'Content-Type': 'application/json',
        'access-token': os.getenv('GALXE_ACCESS_TOKEN')
    }
    
    payload = {
        'query': query,
        'variables': variables or {}
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                'https://graphigo-business.prd.galaxy.eco/query',
                headers=headers,
                json=payload
            ) as response:
                data = await response.json()
                
                if 'errors' in data and data['errors']:
                    error = data['errors'][0]
                    raise GraphQLError(
                        error['message'],
                        error.get('extensions')
                    )
                
                return data['data']
                
    except aiohttp.ClientError as e:
        raise Exception(f"Network error: {str(e)}")
    except json.JSONDecodeError as e:
        raise Exception(f"Failed to parse response: {str(e)}")
```
</CodeGroup>

## 7. Rate Limit Handling

<CodeGroup>
```javascript JavaScript
class GalxeClient {
  constructor(accessToken) {
    this.accessToken = accessToken;
    this.requestQueue = [];
    this.isProcessing = false;
  }

  async query(query, variables) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push({ query, variables, resolve, reject });
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.isProcessing || this.requestQueue.length === 0) return;
    
    this.isProcessing = true;
    
    while (this.requestQueue.length > 0) {
      const { query, variables, resolve, reject } = this.requestQueue.shift();
      
      try {
        const result = await this.executeQuery(query, variables);
        resolve(result);
      } catch (error) {
        if (error.status === 429) {
          // Rate limited, wait and retry
          await this.sleep(60000); // Wait 1 minute
          this.requestQueue.unshift({ query, variables, resolve, reject });
        } else {
          reject(error);
        }
      }
      
      // Add delay between requests
      await this.sleep(100);
    }
    
    this.isProcessing = false;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

```go Go
package main

import (
    "context"
    "fmt"
    "net/http"
    "sync"
    "time"
)

type GalxeClient struct {
    accessToken    string
    requestQueue   chan *Request
    isProcessing   bool
    processingMutex sync.Mutex
}

type Request struct {
    Query     string
    Variables map[string]interface{}
    Response  chan Response
}

type Response struct {
    Data  interface{}
    Error error
}

func NewGalxeClient(accessToken string) *GalxeClient {
    client := &GalxeClient{
        accessToken:  accessToken,
        requestQueue: make(chan *Request, 100),
        isProcessing: false,
    }
    go client.processQueue()
    return client
}

func (c *GalxeClient) Query(query string, variables map[string]interface{}) (interface{}, error) {
    req := &Request{
        Query:     query,
        Variables: variables,
        Response:  make(chan Response, 1),
    }
    
    c.requestQueue <- req
    response := <-req.Response
    
    return response.Data, response.Error
}

func (c *GalxeClient) processQueue() {
    for req := range c.requestQueue {
        c.processingMutex.Lock()
        if c.isProcessing {
            c.processingMutex.Unlock()
            continue
        }
        c.isProcessing = true
        c.processingMutex.Unlock()
        
        result, err := c.executeQuery(req.Query, req.Variables)
        if err != nil {
            // Check if rate limited (HTTP 429)
            if httpErr, ok := err.(*HTTPError); ok && httpErr.StatusCode == 429 {
                // Wait and retry
                time.Sleep(60 * time.Second)
                c.requestQueue <- req // Re-queue the request
                continue
            }
            req.Response <- Response{Error: err}
        } else {
            req.Response <- Response{Data: result}
        }
        
        // Add delay between requests
        time.Sleep(100 * time.Millisecond)
        
        c.processingMutex.Lock()
        c.isProcessing = false
        c.processingMutex.Unlock()
    }
}

type HTTPError struct {
    StatusCode int
    Message    string
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}
```

```python Python
import asyncio
import aiohttp
import time
from typing import Dict, Any, Optional

class GalxeClient:
    def __init__(self, access_token: str):
        self.access_token = access_token
        self.request_queue = asyncio.Queue()
        self.is_processing = False
        self.processing_lock = asyncio.Lock()
        
    async def query(self, query: str, variables: Optional[Dict[str, Any]] = None) -> Any:
        future = asyncio.Future()
        await self.request_queue.put({
            'query': query,
            'variables': variables or {},
            'future': future
        })
        
        if not self.is_processing:
            asyncio.create_task(self.process_queue())
        
        return await future
    
    async def process_queue(self):
        async with self.processing_lock:
            if self.is_processing:
                return
            self.is_processing = True
        
        try:
            while not self.request_queue.empty():
                request = await self.request_queue.get()
                
                try:
                    result = await self.execute_query(
                        request['query'], 
                        request['variables']
                    )
                    request['future'].set_result(result)
                except Exception as error:
                    if hasattr(error, 'status') and error.status == 429:
                        # Rate limited, wait and retry
                        await asyncio.sleep(60)  # Wait 1 minute
                        await self.request_queue.put(request)  # Re-queue
                        continue
                    else:
                        request['future'].set_exception(error)
                
                # Add delay between requests
                await asyncio.sleep(0.1)
        finally:
            async with self.processing_lock:
                self.is_processing = False
    
    async def execute_query(self, query: str, variables: Dict[str, Any]) -> Any:
        # Implementation from the error handling pattern above
        return await execute_graphql_query(query, variables)
```
</CodeGroup>

## Best Practices

1. **Always check quest status** before showing participation UI
2. **Implement proper pagination** for large datasets
3. **Handle rate limits gracefully** with exponential backoff
4. **Cache frequent queries** to reduce API calls
5. **Validate user inputs** before sending to API
6. **Use environment variables** for access tokens
7. **Implement retry logic** for network failures

## Next Steps

- **[Quests](/galxe-integration/guides/quests)** - Complete quest workflow
- **[Loyalty Programs](/galxe-integration/guides/loyalty-program)** - Points and rewards integration
- **[API Reference](/galxe-integration/api-reference/quest)** - Detailed API documentation 